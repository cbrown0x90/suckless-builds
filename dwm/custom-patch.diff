diff -Naur ../dwm-6.1/config.def.h ./config.def.h
--- ../dwm-6.1/config.def.h	2015-11-08 17:39:37.000000000 -0500
+++ ./config.def.h	2015-11-10 09:43:14.080356128 -0500
@@ -54,9 +54,10 @@
 
 /* commands */
 static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbgcolor, "-sf", selfgcolor, NULL };
+static const char *dmenucmd[] = { "dmenu_run", "-b", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbgcolor, "-sf", selfgcolor, NULL };
 static const char *termcmd[]  = { "st", NULL };
 
+#include "movestack.c"
 static Key keys[] = {
 	/* modifier                     key        function        argument */
 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
@@ -68,6 +69,8 @@
 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+	{ MODKEY|ShiftMask,             XK_j,      movestack,      {.i = +1 } },
+	{ MODKEY|ShiftMask,             XK_k,      movestack,      {.i = -1 } },
 	{ MODKEY,                       XK_Return, zoom,           {0} },
 	{ MODKEY,                       XK_Tab,    view,           {0} },
 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
diff -Naur ../dwm-6.1/config.h ./config.h
--- ../dwm-6.1/config.h	1969-12-31 19:00:00.000000000 -0500
+++ ./config.h	2015-11-10 09:43:14.080356128 -0500
@@ -0,0 +1,143 @@
+/* See LICENSE file for copyright and license details. */
+
+/* appearance */
+static const char *fonts[] = {
+	"gohufont:pixelsize=11",
+        "Font Awesome:pixelsize=11"
+};
+static const char dmenufont[]       = "Source Code Pro:size=8";
+static const char normbordercolor[] = "#444444";
+static const char normbgcolor[]     = "#222222";
+static const char normfgcolor[]     = "#bbbbbb";
+static const char selbordercolor[]  = "#bbbbbb";
+static const char selbgcolor[]      = "#bbbbbb";
+static const char selfgcolor[]      = "#222222";
+static const unsigned int borderpx  = 1;        /* border pixel of windows */
+static const unsigned int snap      = 32;       /* snap pixel */
+static const int showbar            = 1;        /* 0 means no bar */
+static const int topbar             = 0;        /* 0 means bottom bar */
+static const Bool statusmarkup      = True;     /* True means use pango markup in status message */
+
+/* tagging */
+static const char *tags[] = { "1: Web", "2: Personal", "3: Work", "4: Misc", "5: Music" };
+
+static const Rule rules[] = {
+	/* xprop(1):
+	 *	WM_CLASS(STRING) = instance, class
+	 *	WM_NAME(STRING) = title
+	 */
+	/* class      instance    title       tags mask     isfloating   monitor */
+	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+};
+
+/* layout(s) */
+static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+static const int nmaster     = 1;    /* number of clients in master area */
+static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+
+static const Layout layouts[] = {
+	/* symbol     arrange function */
+	{ "[]=",      tile },    /* first entry is default */
+	{ "><>",      NULL },    /* no layout function means floating behavior */
+	{ "[M]",      monocle },
+};
+
+/* key definitions */
+#define MODKEY Mod4Mask
+#define TAGKEYS(KEY,TAG) \
+	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
+	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
+
+/* helper for spawning shell commands in the pre dwm-5.0 fashion */
+#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+
+/* commands */
+static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+static const char *dmenucmd[] = { "/home/chris/.scripts/helper\ scripts/dmenu_start", NULL };
+static const char *termcmd[]  = { "st", NULL };
+static const char *web[] = { "chromium", NULL };
+static const char *lock[] = { "slock", NULL };
+static const char *surf[] = { "tabbed", "-c", "surf", "-e", NULL };
+static const char *ncmpcpp[] = { "st", "-e", "ncmpcpp", NULL };
+static const char *screenshot[] = { "/home/chris/.scripts/helper\ scripts/screenshot", NULL };
+static const char *audio_mute[] = { "amixer", "sset", "Master", "toggle", NULL };
+static const char *audio_raise[] = { "amixer", "sset", "Master", "5%-", NULL };
+static const char *audio_lower[] = { "amixer", "sset", "Master", "5%+", NULL };
+static const char *bright_up[] = { "/home/chris/.scripts/bright_up", NULL };
+static const char *bright_down[] = { "/home/chris/.scripts/bright_down", NULL };
+static const char *mopidy_prev[] = { "/home/chris/.scripts/mopidy\ commands/mopidy_previous", NULL };
+static const char *mopidy_next[] = { "/home/chris/.scripts/mopidy\ commands/mopidy_next", NULL };
+static const char *mopidy_play[] = { "/home/chris/.scripts/mopidy\ commands/mopidy_play", NULL };
+
+#include "movestack.c"
+static Key keys[] = {
+	/* modifier                     key        function        argument */
+        { MODKEY,                       XK_d,      spawn,          {.v = dmenucmd } },
+        { MODKEY,                       XK_Return, spawn,          {.v = termcmd } },
+        { MODKEY,                       XK_c,      spawn,          {.v = web } },
+        { MODKEY,                       XK_b,      togglebar,      {0} },
+        { MODKEY,                       XK_s,      spawn,          {.v = surf } },
+        { MODKEY,                       XK_n,      spawn,          {.v = ncmpcpp } },
+        { 0,                            XK_Print, spawn,         {.v = screenshot } },
+        { 0,                            0x1008ff12, spawn,         {.v = audio_mute } },
+        { 0,                            0x1008ff11, spawn,         {.v = audio_raise } },
+        { 0,                            0x1008ff13, spawn,         {.v = audio_lower } },
+        { 0,                            0x1008ff02, spawn,         {.v = bright_up } },
+        { 0,                            0x1008ff03, spawn,         {.v = bright_down} },
+        { 0,                            XK_F9, spawn,         {.v = mopidy_prev } },
+        { 0,                            XK_F10, spawn,         {.v = mopidy_play } },
+        { 0,                            XK_F11, spawn,         {.v = mopidy_next } },
+        { MODKEY|ShiftMask,             XK_l,      spawn,          {.v = lock } },
+        { MODKEY,                       XK_Left,   focusstack,     {.i = -1 } },
+        { MODKEY,                       XK_Right,  focusstack,     {.i = +1 } },
+        { MODKEY|ShiftMask,             XK_Left,   movestack,      {.i = -1 } },
+        { MODKEY|ShiftMask,             XK_Right,  movestack,      {.i = +1 } },
+        { MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+        { MODKEY,                       XK_u,      incnmaster,     {.i = -1 } },
+        { MODKEY,                       XK_k,      setmfact,       {.f = -0.05} },
+        { MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+        { MODKEY,                       XK_Tab,    view,           {0} },
+        { MODKEY|ShiftMask,             XK_q,      killclient,     {0} },
+        { MODKEY,                       XK_e,      setlayout,      {.v = &layouts[0]} },
+        { MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
+        { MODKEY,                       XK_w,      setlayout,      {.v = &layouts[2]} },
+        { MODKEY,                       XK_space,  setlayout,      {0} },
+        { MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
+        { MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+        { MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+        { MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+        { MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+        { MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+        { MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+        TAGKEYS(                        XK_1,                      0)
+	TAGKEYS(                        XK_2,                      1)
+	TAGKEYS(                        XK_3,                      2)
+	TAGKEYS(                        XK_4,                      3)
+	TAGKEYS(                        XK_5,                      4)
+	TAGKEYS(                        XK_6,                      5)
+	TAGKEYS(                        XK_7,                      6)
+	TAGKEYS(                        XK_8,                      7)
+	TAGKEYS(                        XK_9,                      8)
+	{ MODKEY|ShiftMask,             XK_e,      quit,           {0} },
+};
+
+/* button definitions */
+/* click can be ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
+static Button buttons[] = {
+	/* click                event mask      button          function        argument */
+	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+	{ ClkTagBar,            0,              Button1,        view,           {0} },
+	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
+	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+	{ ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
+};
+
diff -Naur ../dwm-6.1/config.mk ./config.mk
--- ../dwm-6.1/config.mk	2015-11-08 17:39:37.000000000 -0500
+++ ./config.mk	2015-11-10 09:43:14.080356128 -0500
@@ -18,11 +18,11 @@
 FREETYPELIBS = -lfontconfig -lXft
 FREETYPEINC = /usr/include/freetype2
 # OpenBSD (uncomment)
-FREETYPEINC = ${X11INC}/freetype2
+#FREETYPEINC = ${X11INC}/freetype2
 
 # includes and libs
-INCS = -I${X11INC} -I${FREETYPEINC}
-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
+INCS = -I. -I/usr/include -I${X11INC} `pkg-config --cflags xft pango pangoxft` -I${FREETYPEINC}
+LIBS = -L/usr/lib -lc -L${X11LIB} -lX11 ${XINERAMALIBS} `pkg-config --libs xft pango pangoxft` ${FREETYPELIBS}
 
 # flags
 CPPFLAGS = -D_BSD_SOURCE -D_POSIX_C_SOURCE=2 -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
diff -Naur ../dwm-6.1/dwm.c ./dwm.c
--- ../dwm-6.1/dwm.c	2015-11-08 17:39:37.000000000 -0500
+++ ./dwm.c	2015-11-10 09:43:14.080356128 -0500
@@ -36,6 +36,9 @@
 #include <X11/Xlib.h>
 #include <X11/Xproto.h>
 #include <X11/Xutil.h>
+#include <X11/Xft/Xft.h>
+#include <pango/pango.h>
+#include <pango/pangoxft.h>
 #ifdef XINERAMA
 #include <X11/extensions/Xinerama.h>
 #endif /* XINERAMA */
@@ -49,7 +52,8 @@
 #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
 #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
+#define ISVISIBLEONTAG(C, T)    ((C->tags & T))
+#define ISVISIBLE(C)            ISVISIBLEONTAG(C, C->mon->tagset[C->mon->seltags])
 #define LENGTH(X)               (sizeof X / sizeof X[0])
 #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
@@ -147,6 +151,7 @@
 static void arrange(Monitor *m);
 static void arrangemon(Monitor *m);
 static void attach(Client *c);
+static void attachaside(Client *c);
 static void attachstack(Client *c);
 static void buttonpress(XEvent *e);
 static void checkotherwm(void);
@@ -184,6 +189,7 @@
 static void monocle(Monitor *m);
 static void motionnotify(XEvent *e);
 static void movemouse(const Arg *arg);
+static Client *nexttagged(Client *c);
 static Client *nexttiled(Client *c);
 static void pop(Client *);
 static void propertynotify(XEvent *e);
@@ -236,7 +242,7 @@
 
 /* variables */
 static const char broken[] = "broken";
-static char stext[256];
+static char stext[512];
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh, blw = 0;      /* bar geometry */
@@ -379,10 +385,13 @@
 void
 arrange(Monitor *m)
 {
-	if (m)
+	if (m) {
+                adjustborders(m);
 		showhide(m->stack);
-	else for (m = mons; m; m = m->next)
+        } else for (m = mons; m; m = m->next) {
+                adjustborders(m);
 		showhide(m->stack);
+        }
 	if (m) {
 		arrangemon(m);
 		restack(m);
@@ -406,6 +415,17 @@
 }
 
 void
+attachaside(Client *c) {
+    Client *at = nexttagged(c);
+    if(!at) {
+        attach(c);
+        return;
+    }
+    c->next = at->next;
+    at->next = c;
+}
+
+void
 attachstack(Client *c)
 {
 	c->snext = c->mon->stack;
@@ -430,9 +450,15 @@
 	}
 	if (ev->window == selmon->barwin) {
 		i = x = 0;
-		do
-			x += TEXTW(tags[i]);
-		while (ev->x >= x && ++i < LENGTH(tags));
+		unsigned int occ = 0;
+                for(c = m->clients; c; c = c->next)
+                    occ |= c->tags;
+                do {
+                    /* do not reserve space for vacant tags */
+                    if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+                        continue;
+		    x += TEXTW(tags[i]);
+            } while (ev->x >= x && ++i < LENGTH(tags));
 		if (i < LENGTH(tags)) {
 			click = ClkTagBar;
 			arg.ui = 1 << i;
@@ -717,12 +743,15 @@
 	}
 	x = 0;
 	for (i = 0; i < LENGTH(tags); i++) {
-		w = TEXTW(tags[i]);
+	    /* do not draw vacant tags */
+            if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+                continue;
+                w = TEXTW(tags[i]);
 		drw_setscheme(drw, m->tagset[m->seltags] & 1 << i ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
 		drw_text(drw, x, 0, w, bh, tags[i], urg & 1 << i);
 		drw_rect(drw, x + 1, 1, dx, dx, m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
-		           occ & 1 << i, urg & 1 << i);
-		x += w;
+		    0, urg & 1 << i);
+                x += w;
 	}
 	w = blw = TEXTW(m->ltsymbol);
 	drw_setscheme(drw, &scheme[SchemeNorm]);
@@ -843,6 +872,35 @@
 }
 
 void
+adjustborders(Monitor *m) {
+    Client *c, *l = NULL;
+    int visible = 0;
+  
+    for(c = m->clients; c; c = c->next) {
+        if (ISVISIBLE(c) && !c->isfloating && m->lt[m->sellt]->arrange) {
+            if (m->lt[m->sellt]->arrange == monocle) {
+                visible = 1;
+                c->oldbw = c->bw;
+                c->bw = 0;
+            } else {
+                visible++;
+                c->oldbw = c->bw;
+                c->bw = borderpx;
+        }
+    
+        l = c;
+        }
+    }
+  
+    if (l && visible == 1 && l->bw) {
+        l->oldbw = l->bw;
+        l->bw = 0;
+        resizeclient(l, l->x, l->y, l->w, l->h);
+    }
+}
+
+
+void
 focusstack(const Arg *arg)
 {
 	Client *c = NULL, *i;
@@ -1061,7 +1119,20 @@
 	/* only fix client y-offset, if the client center might cover the bar */
 	c->y = MAX(c->y, ((c->mon->by == c->mon->my) && (c->x + (c->w / 2) >= c->mon->wx)
 	           && (c->x + (c->w / 2) < c->mon->wx + c->mon->ww)) ? bh : c->mon->my);
-	c->bw = borderpx;
+
+	updatewindowtype(c);
+	if (c->isfloating) {
+		c->bw = c->isfullscreen ? 0 : borderpx;
+	} else {
+		c->bw = 0;
+		for(t = c->mon->clients; t; t = c->next) {
+			if (!t->isfloating && c != t && c->tags & t->tags) {
+				c->bw = borderpx;
+				break;
+			}
+		}
+		adjustborders(c->mon);
+	}
 
 	wc.border_width = c->bw;
 	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
@@ -1076,7 +1147,7 @@
 		c->isfloating = c->oldstate = trans != None || c->isfixed;
 	if (c->isfloating)
 		XRaiseWindow(dpy, c->win);
-	attach(c);
+	attachaside(c);
 	attachstack(c);
 	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
 	                (unsigned char *) &(c->win), 1);
@@ -1210,6 +1281,16 @@
 }
 
 Client *
+nexttagged(Client *c) {
+    Client *walked = c->mon->clients;
+    for(;
+        walked && (walked->isfloating || !ISVISIBLEONTAG(walked, c->tags));
+        walked = walked->next
+    );
+    return walked;
+}
+
+Client *
 nexttiled(Client *c)
 {
 	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
@@ -1434,7 +1515,7 @@
 	detachstack(c);
 	c->mon = m;
 	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
-	attach(c);
+	attachaside(c);
 	attachstack(c);
 	focus(NULL);
 	arrange(NULL);
@@ -1891,7 +1972,7 @@
 					m->clients = c->next;
 					detachstack(c);
 					c->mon = mons;
-					attach(c);
+					attachaside(c);
 					attachstack(c);
 				}
 				if (m == selmon)
@@ -2003,7 +2084,8 @@
 	Atom state = getatomprop(c, netatom[NetWMState]);
 	Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
 
-	if (state == netatom[NetWMFullscreen])
+	if (state == netatom[NetWMFullscreen] ||
+                (WIDTH(c) == (c->mon->mx + c->mon->mw) && (HEIGHT(c) == (c->mon->my + c->mon->mh))))
 		setfullscreen(c, 1);
 	if (wtype == netatom[NetWMWindowTypeDialog])
 		c->isfloating = 1;
diff -Naur ../dwm-6.1/movestack.c ./movestack.c
--- ../dwm-6.1/movestack.c	1969-12-31 19:00:00.000000000 -0500
+++ ./movestack.c	2015-11-10 09:43:14.080356128 -0500
@@ -0,0 +1,49 @@
+void
+movestack(const Arg *arg) {
+	Client *c = NULL, *p = NULL, *pc = NULL, *i;
+
+	if(arg->i > 0) {
+		/* find the client after selmon->sel */
+		for(c = selmon->sel->next; c && (!ISVISIBLE(c) || c->isfloating); c = c->next);
+		if(!c)
+			for(c = selmon->clients; c && (!ISVISIBLE(c) || c->isfloating); c = c->next);
+
+	}
+	else {
+		/* find the client before selmon->sel */
+		for(i = selmon->clients; i != selmon->sel; i = i->next)
+			if(ISVISIBLE(i) && !i->isfloating)
+				c = i;
+		if(!c)
+			for(; i; i = i->next)
+				if(ISVISIBLE(i) && !i->isfloating)
+					c = i;
+	}
+	/* find the client before selmon->sel and c */
+	for(i = selmon->clients; i && (!p || !pc); i = i->next) {
+		if(i->next == selmon->sel)
+			p = i;
+		if(i->next == c)
+			pc = i;
+	}
+
+	/* swap c and selmon->sel selmon->clients in the selmon->clients list */
+	if(c && c != selmon->sel) {
+		Client *temp = selmon->sel->next==c?selmon->sel:selmon->sel->next;
+		selmon->sel->next = c->next==selmon->sel?c:c->next;
+		c->next = temp;
+
+		if(p && p != c)
+			p->next = c;
+		if(pc && pc != selmon->sel)
+			pc->next = selmon->sel;
+
+		if(selmon->sel == selmon->clients)
+			selmon->clients = c;
+		else if(c == selmon->clients)
+			selmon->clients = selmon->sel;
+
+		arrange(selmon);
+	}
+}
+
